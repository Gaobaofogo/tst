#!/usr/bin/env python
# coding: utf-8
# (c) 2011-2014 Dalton Serey, UFCG
#
# TST Commander. Invokes TST commands. It supports both internal
# and external commands. Internal commands are functions within
# this script named 'tst_*' and external commands are scripts
# named 'tst-*.py' contained in the ~/.tst/commands directory.
#
# To invoke a command, use the general syntax:
#
#       $ tst <command-name> [<arg> [<arg> ...]]
#
# If no recognized <command-name> is supplied, the
# DEFAULT_COMMAND will be invoked.

from __future__ import print_function
from __future__ import unicode_literals
import sys
import os

from subprocess import Popen, PIPE, check_call, CalledProcessError

import tstlib as tst

# TST INTERNAL COMMANDS
DEFAULT_COMMAND = 'test'
EXTERNALS = ["update", "login", "checkout", "test", "commit", "config"]
HIDDEN = ['checkout2', 'commit2', 'status', 'new', 'add']
INTERNALS = ["help", "version", "sharing", "add", "ls", "remove"]

def tst_help(args):
    """short description of commands"""
    print("usage: tst [<command>] [<args>]\n")
    print("Available commands:\n")
    for cmd in INTERNALS:
        print("  %-12s%s" % (cmd, globals()['tst_' + cmd].__doc__))
    for cmd in EXTERNALS:
        print("  %-12s%s" % (cmd, get_one_line_help(cmd)))
 
    custom = custom_commands()
    if custom:
        print("\nCustom commands:")
        for cmd in custom_commands():
            print("  %-12s%s" % (cmd, get_one_line_help(cmd)))


def tst_version(args):
    """print version of currently installed tst"""
    try:
        release_file = os.path.expanduser("~/.tst/release.json")
        release = open(release_file).read().split('"')[3]
        msg = "tst version %s" % release
    except:
        msg = "your tst installation is either corrupted or outdated"

    print(msg)


def tst_sharing(args):
    if len(args) == 1:
        print("usage: tst sharing <add|remove> <username>")
        sys.exit(1)
        
    tstjson = tst.read_tstjson()
    if len(args) == 0:
        # list all collaborators
        collaborators =  tstjson['collaborators']
        if collaborators:
            print("# Collaborators\n")
            print("  " + tstjson['owner'] + " (owner)")
            for c in collaborators:
                print("  " + c)
            print()
        sys.exit()
        
    # add collaborators
    action = args[0]
    if action != 'add':
        print("tst: fatal: unknown sharing action")
        sys.exit(1)

    config = tst.read_config()
    domain = config.get('domain', '')
    usernames = []
    for i in xrange(1, len(args)):
        un = args[i] if '@' in args[i] else args[i] + '@' + domain
        usernames.append(un)

    server = tst.Server()
    activity = tstjson['iid']
    url = config['url'] + '/api/activity/%s/collaborators' % activity
    response = server.post(url, usernames)
    if True: # response.status_code != 200:
        print("tst: error")
        print(response.stdout)
        sys.exit()


def tst_ls(args):
    tstjson = tst.read_tstjson()
    files = tstjson.setdefault('files', {})
    for fn in sorted(files.keys()):
        visibility = files[fn].get('category', 'private')
        print(fn, ("(%s)" % visibility if visibility == 'public' else ''))


def tst_remove(args):
    tstjson = tst.read_tstjson()
    files = tstjson.setdefault('files', {})
    if any(f not in files for f in args):
        print("Some of the files don't exist.")
        print("Operation aborted.")
        sys.exit(1)

    removed = {}
    for f in args:
        removed[f] = files.pop(f)

    tst.save_tstjson(tstjson)
    for f in removed:
        print('removed: %s %s' % (removed[f].get('category', 'private'), f))


def tst_add(args):
    tstjson = tst.read_tstjson()
    visibility = args.pop(0) if args[0] in ('public', 'private') else None
    files = tstjson.setdefault('files', {})
    if any(f in files for f in args):
        print("Some files already exist.")
        print("Operation aborted.")
        sys.exit(1)

    added = []
    for f in args:
        if f in added:
            continue
        added.append(f)
        filedict = files.setdefault(f, {})
        if visibility:
            filedict['category'] = visibility

    tst.save_tstjson(tstjson)
    for f in added:
        print('added: %s %s' % (files[f].get('category', 'private'), f))


def get_one_line_help(command):

    script = os.path.expanduser("~/.tst/commands/tst-%s" % command)
    try:
        process = Popen([script, "--one-line-help"], stdout=PIPE, stderr=PIPE)
    except:
        return "<no help available>"

    try:
        stdout, stderr = process.communicate()
    except: # something went wrong
        return "<no help available>"

    # collect report from stderr or stdout
    return stdout.strip().splitlines()[0]


def run_command_script(command, args):
    script_name = os.path.expanduser("~/.tst/commands/tst-%s" % command)
    args.insert(0, script_name)
    try:
        check_call(args)
    except CalledProcessError:
        pass
    except OSError:
        print("tst: couldn't run command '%s'" % command, file=sys.stderr)


def custom_commands():
    commands = os.environ.get("TST_CUSTOM_COMMANDS")
    return [] if commands is None else commands.split(":")


def identify_and_run_command(args):

    if args and args[0] in INTERNALS:
        command_name = args.pop(0) # discard command name
        run_internal_command = globals()["tst_" + command_name]
        run_internal_command(args)

    elif args and (args[0] in EXTERNALS or args[0] in custom_commands() or args[0] in HIDDEN):
        command_name = args.pop(0)
        run_command_script(command_name, args)

    else: # neither internal, nor external command!?
        command_name = DEFAULT_COMMAND
        run_command_script(command_name, args)


if __name__ == "__main__":
    # make a safe and mutable copy of the arguments list
    args = sys.argv[:]
    args.pop(0) # discard commander name (tst)
    identify_and_run_command(args)
